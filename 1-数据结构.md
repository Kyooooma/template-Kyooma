# 数据结构

## st表

$st[i][j]$表示区间$[i, i + 2 ^ j - 1]$的gcd

```cpp
int st[N][Log + 5], logx[N];

void init(int n) {
    logx[0] = -1;
    for (int i = 1; i <= n; i++)logx[i] = logx[i >> 1] + 1;
    for (int i = 1; i <= n; i++)st[i][0] = i;
    for (int j = 1; (1 << j) <= n; j++) {
        for (int i = 1; i + (1 << j) - 1 <= n; i++) {
            st[i][j] = __gcd(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);
        }
    }
}

int query(int l, int r){
    int k = logx[r - l + 1];
    return __gcd(st[l][k], st[r - (1 << k) + 1][k]);
}
```



## 树状数组

```cpp
int sum[N], n;

int lowbit(int x) {
    return x & -x;
}
void update(int p, int v) {
    while (p <= n) {
        sum[p] += v;
        p += lowbit(p);
    }
}
int query(int p) {
    int ans = 0;
    while (p) {
        ans += sum[p];
        p -= lowbit(p);
    }
    return ans;
}
```

```cpp
template <typename T>
struct Fenwick {
    const int n;
    vector<T> a;
    Fenwick(int n) : n(n), a(n + 1) {}
    void add(int x, T v) {
        while(x <= n){
            a[x] += v;
            x += x & -x;
        }
    }
    T sum(int x) {
        T ans = 0;
        for (int i = x; i; i -= i & -i) {
            ans += a[i];
        }
        return ans;
    }
    T rangeSum(int l, int r) {
        return sum(r) - sum(l - 1);
    }
};
```



## Segment Tree

```cpp
template<typename T>
struct SegmentTree{
    T sum[N << 2], lz[N << 2];
    void apply(int k, int l, int r, T x){
        sum[k] += (r - l + 1) * x;
        lz[k] += x;
    }
    void pd(int k, int l, int r){// push down
        int mid = (l + r) >> 1;
        apply(k << 1, l, mid, lz[k]);
        apply(k << 1 | 1, mid + 1, r, lz[k]);
        lz[k] = 0;
    }
    void pu(int k){// push up
        sum[k] = sum[k << 1] + sum[k << 1 | 1];
    }
    void build(int k, int l, int r){
        if(l == r){
            sum[k] = a[l];
            lz[k] = 0;
            return;
        }
        int mid = (l + r) >> 1;
        build(k << 1, l, mid);
        build(k << 1 | 1, mid + 1, r);
        pu(k);
    }
    void mdf(int k, int l, int r, int ql, int qr, T x){// modify [ql, qr] add x
        if(l > qr || r < ql) return;
        if(l >= ql && r <= qr){
            sum[k] += (r - l + 1) * x;
            lz[k] += x;
            return;
        }
        pd(k, l, r);
        int mid = (l + r) >> 1;
        mdf(k << 1, l, mid, ql, qr, x);
        mdf(k << 1 | 1, mid + 1, r, ql, qr, x);
        pu(k);
    }
    T query(int k, int l, int r, int ql, int qr){
        if(l > qr || r < ql) return 0;
        if(l >= ql && r <= qr){
            return sum[k];
        }
        pd(k, l, r);
        int mid = (l + r) >> 1;
        return query(k << 1, l, mid, ql, qr) + query(k << 1 | 1, mid + 1, r, ql, qr);
    }
};
```



## 主席树

```cpp
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
const int N = 200010;
int root[N], tot = 0, num[N], len, a[N];
struct Info {
    int sum, l, r;
} info[N << 5];

int getid(int x) {
    return lower_bound(num + 1, num + len + 1, x) - num;
}

void build(int &x, int l, int r) {//创建空树
    x = ++tot;
    info[x].sum = 0;
    if (l == r) return;
    int mid = (l + r) / 2;
    build(info[x].l, l, mid);
    build(info[x].r, mid + 1, r);
}

void update(int pre, int &now, int l, int r, int q) {//更新
    now = ++tot;
    info[now] = info[pre];
    info[now].sum++;
    if (l == r) return;
    int mid = (l + r) / 2;
    if (mid >= q) update(info[pre].l, info[now].l, l, mid, q);
    else update(info[pre].r, info[now].r, mid + 1, r, q);
}

int query(int pre, int now, int l, int r, int k) {//求第k小
    if (l == r) return l;
    int delta = info[info[now].l].sum - info[info[pre].l].sum;
    int mid = (l + r) / 2;
    if (delta >= k) return query(info[pre].l, info[now].l, l, mid, k);
    else return query(info[pre].r, info[now].r, mid + 1, r, k - delta);
}

int query_sum(int pre, int now, int l, int r, int k) {// 求小于等于k的个数
    if (l == r) return info[now].sum - info[pre].sum;
    int mid = (l + r) >> 1;
    if (k <= mid) return query_sum(info[pre].l, info[now].l, l, mid, k);
    else return (info[info[now].l].sum - info[info[pre].l].sum) + query_sum(info[pre].r, info[now].r, mid + 1, r, k);
}
/*
先进行离散化 
sort(num + 1, num + 1 + n);
len = unique(num + 1, num + 1 + n) - num - 1;
建空树
build(root[0], 1, len);
更新
update(root[i - 1], root[i], 1, len, getid(a[i]));
查询[l, r]
query_sum(root[l - 1], root[r], 1, len, k)
query(root[l - 1], root[r], 1, len, k)
*/
```
