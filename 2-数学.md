# 数学

## 组合数预处理

```cpp
ll f[N], inv[N];

ll qpow(ll a, ll b) {
    ll res = 1;
    while (b) {
        if (b & 1) res = res * a % mod;
        a = a * a % mod;
        b /= 2;
    }
    return res;
}

ll C(ll n, ll m) {
    return f[n] * inv[m] % mod * inv[n - m] % mod;
}

void init(int M) {
    f[0] = 1;
    for (int i = 1; i <= M; i++) f[i] = f[i - 1] * i % mod;
    inv[M] = qpow(f[M], mod - 2);
    for (int i = M - 1; i >= 0; i--) inv[i] = inv[i + 1] * (i + 1) % mod;
}
```



## Exgcd

求解 $xa + yb = c$ 

有解需满足  $gcd(a, b) | c$ 

设解出的一组特解为 $x_0, y_0$ 则通解为 $x = x_0 + tb, y = y_0 - ta$

```cpp
ll exgcd(ll a, ll b, ll &x, ll &y) {
    if (!b) {
        x = 1;
        y = 0;
        return a;
    } else {
        ll g = exgcd(b, a % b, x, y);
        ll t = x;
        x = y;
        y = t - a / b * y;
        return g;
    }
}

ll upper(ll m, ll n) {//向上取整
    if (m <= 0) return m / n;
    return (m - 1) / n + 1;
}

ll lower(ll m, ll n) {//向下取整
    if (m >= 0) return m / n;
    return (m + 1) / n - 1;
}
```



## Lucas 定理

适用于模数为小质数

$C_n^m\ \ mod\ \ p = C_{n\ \ mod \ \ p}^{m\ \ mod \ \ p} \times C_{\lfloor \frac{n}{p}\rfloor } ^ {\lfloor \frac{m}{p}\rfloor}\ \ mod\ \ p$

```cpp
ll C(ll n, ll r, ll p) {
    if (r > n || r < 0) return 0;
    return f[n] * inv[r] % p * inv[n - r] % p;
}

ll Lucas(ll n, ll m, ll p) {
    if (m == 0) return 1;
    return (C(n % p, m % p, p) * Lucas(n / p, m / p, p)) % p;
}
```



## 欧拉筛

```cpp
const int N = 1e4 + 10, M = 10000;
vector<int> p;
int vis[N];

void init() {
    for (int i = 2; i <= M; i++) {
        if (!vis[i]) {
            p.push_back(i);
        }
        for (int j = 0; j < p.size() && p[j] * i <= M; j++) {
            vis[p[j] * i] = 1;
            if (i % p[j] == 0) {
                break;
            }
        }
    }
}
```

#### 求欧拉函数 : $phi(n) = n\prod (1-\frac{1}{p_i})$

```cpp
const int N = 1e4 + 10, M = 10000;
vector<int> p;
int phi[N], vis[N];

void rua() {//欧拉筛 以及 求欧拉函数
    for (int i = 2; i <= M; i++) {
        if (!vis[i]) {
            p.push_back(i);
            phi[i] = i - 1;
        }
        for (int j = 0; j < p.size() && p[j] * i <= M; j++) {
            vis[p[j] * i] = 1;
            if (i % p[j] == 0) {
                phi[i * p[j]] = phi[i] * p[j];
                break;
            } else {
                phi[i * p[j]] = phi[i] * phi[p[j]];
            }
        }
    }
}
```



## 线性基

线性基是一个数的集合，并且每个序列都拥有至少一个线性基，取线性基中若干个数异或起来可以得到原序列中的任何一个数。
原序列里面的任意一个数都可以由线性基里面的一些数异或得到
线性基里面的任意一些数异或起来都不能得到0
线性基里面的数的个数唯一，并且在保持性质一的前提下，数的个数是最少的

```cpp
ll d[Log + 5];

void add(ll x){// 线性基插入
    for(int i = Log; i >= 0; i--){
        if((x >> i) & 1){
            if(d[i]) x ^= d[i];
            else{
                d[i] = x; // 插入成功
                break;
            }
        }
    }
}
```



## 欧拉降幂

$a^b\pmod m\equiv a^{b \mod \phi(m)+\phi(m)} \pmod m[b\ge \phi(m)]$

**以下代码以计算 $a_l^{a_{l+1}^{a_{l+2}^{...^{a_r}}}}$ 为例**

```cpp
unordered_map<ll, ll> mp;
ll a[N];
ll MOD(ll x, ll mod) {return x < mod ? x : x % mod + mod;}
ll qpow(ll a, ll b, ll mod) {
    ll res = 1;
    while (b) {
        if (b & 1) res = MOD(res * a, mod);
        b /= 2;
        a = MOD(a * a, mod);
    }
    return res;
}
ll phi(ll x) {
    if (mp[x]) return mp[x];
    ll res = x;
    for (ll i = 2; i * i <= x; i++) {
        if (x % i == 0) {
            res -= res / i;
            while (x % i == 0) x /= i;
        }
    }
    if (x > 1) {
        res -= res / x;
    }
    return mp[x] = res;
}
ll solve(int l, int r, ll p) {
    if (p == 1) return MOD(a[l], p);
    if (l == r) return MOD(a[l], p);
 
    return qpow(a[l], solve(l + 1, r, phi(p)), p);
}
```



## 矩阵快速幂

```cpp
const int MOD = 1e9 + 7;

struct mat {
    int n;
    vector<vector<int>> a;

    mat(int n): n(n), a(n, vector<int>(n)){}

    mat operator*(const mat& b) const {
        mat res(n);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                for (int k = 0; k < n; k++) {
                    (res.a[i][j] += 1ll * a[i][k] * b.a[k][j] % MOD) %= MOD;
                }
            }
        }
        return res;
    }

    void print(){
        for(int i = 0; i < n; i++){
            for(int j = 0; j < n; j++){
                cout << a[i][j] << ' ';
            }
            cout << '\n';
        }
        cout << '\n';
    }
};

mat qpow(mat a, ll b) {
    mat res(a.n);
    for (int i = 0; i < a.n; i++) {
        res.a[i][i] = 1;
    }
    while (b) {
        if (b & 1) res = res * a;
        a = a * a, b >>= 1;
    }
    return res;
}
```



## 中国剩余定理

$x = num_i (mod\ \ r_i)$

```cpp
ll CRT(int n) {//适用于ri两两互质
    ll N = 1, res = 0;
    for (int i = 1; i <= n; i++) N *= r[i];
    for (int i = 1; i <= n; i++) {
        ll m = N / r[i], x, y;
        exgcd(m, r[i], x, y);
        res = (res + num[i] * m % N * x % N) % N;
    }
    return (res + N) % N;
}
```

#### **通解解法:**

$x=a_1 (mod\ \ m_1)$

$x=a_2 (mod\ \ m_2)$

$x=k_1 \times m_1 + a_1=k_2 \times m_2 + a_2$

$k_1 \times m_1 - k_2 \times m_2 = a_2 - a_1$

**运用exgcd可求得一组解 (k1,k2) 可将上述两方程化为**

 **$x=k_1 \times m_1 + a_1 (mod \ \ lcm(m_1,m_2))$**

**若有多个方程 依次两两合并即可**



## 整除分块

$\sum_{i = 1}^{n} \lfloor \frac{n}{i} \rfloor$

```cpp
ans = 0;
for(int l = 1, r; l <= n; l = r + 1)
{
    r = n / (n / l);
    ans += n / l * (r - l + 1);
}
```



## 差分推x+y组合数方案

```cpp
#include <bits/stdc++.h>

typedef long long ll;
using namespace std;
const int maxn = 2000005;

/*
A <= x <= B
C <= y <= D
s[i]表示 x+y=i 的方案数
*/

int s[maxn];

int main() {

    int A, B, C, D;
    A = ; B = ;
    C = ; D = ;

    s[A + C]++;
    s[A + D + 1]--;
    s[B + C + 1]--;
    s[B + D + 2]++;

    for (int i = 1; i < maxn; i++) s[i] += s[i - 1];
    for (int i = 1; i < maxn; i++) s[i] += s[i - 1];

    for (int i = A + C; i <= B + D + 2; i++) {
        printf("s[%d] = %d\n", i, s[i]);
    }

    return 0;
}
```



## 拉格朗日插值

设要求的 $n$ 次多项式为 $f(k)$, 已知 $f(x_i) \ \ (1 \le i \le n + 1)$

#### $f(k) = \sum_{i=1}^{n + 1} f(x_i) \prod_{j \ne i}{\frac{k-x_j}{x_i-x_j}}$


设要求的 $n$ 次多项式为 $f(k)$, 已知 $f(i) \ \ (1 \le i \le n + 1)$

#### $f(k) = \sum_{i=1}^{n+1}f(i)\times \frac{\prod_{j=1}^{n+1}(x-j)}{(x-i)\times (-1)^{n+1-i}\times (i-1)! \times (n+1-i)!}$


## FFT
```cpp
const double PI = acos(-1.0);

struct Complex {
    double x, y;

    Complex(double _x = 0.0, double _y = 0.0) {
        x = _x;
        y = _y;
    }

    Complex operator-(const Complex &b) const {
        return {x - b.x, y - b.y};
    }

    Complex operator+(const Complex &b) const {
        return {x + b.x, y + b.y};
    }

    Complex operator*(const Complex &b) const {
        return {x * b.x - y * b.y, x * b.y + y * b.x};
    }
};

/*
 * 进行 FFT 和 IFFT 前的反置变换
 * 位置 i 和 i 的二进制反转后的位置互换
 *len 必须为 2 的幂
 */
void change(Complex y[], int len) {
    int i, j, k;

    for (i = 1, j = len / 2; i < len - 1; i++) {
        if (i < j) swap(y[i], y[j]);

        // 交换互为小标反转的元素，i<j 保证交换一次
        // i 做正常的 + 1，j 做反转类型的 + 1，始终保持 i 和 j 是反转的
        k = len / 2;

        while (j >= k) {
            j = j - k;
            k = k / 2;
        }

        if (j < k) j += k;
    }
}

/*
 * 做 FFT
 * len 必须是 2^k 形式
 * on == 1 时是 DFT，on == -1 时是 IDFT
 * DFT: 系数 -> 点值表示  IDFT: 点值表示 -> 系数
 */
void fft(Complex y[], int len, int on) {
    change(y, len);

    for (int h = 2; h <= len; h <<= 1) {
        Complex wn(cos(2 * PI / h), sin(on * 2 * PI / h));

        for (int j = 0; j < len; j += h) {
            Complex w(1, 0);

            for (int k = j; k < j + h / 2; k++) {
                Complex u = y[k];
                Complex t = w * y[k + h / 2];
                y[k] = u + t;
                y[k + h / 2] = u - t;
                w = w * wn;
            }
        }
    }

    if (on == -1) {
        for (int i = 0; i < len; i++) {
            y[i].x /= len;
        }
    }
}
```
