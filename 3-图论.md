# 图论

## 最小生成树

#### Prim

```cpp
typedef pair<int, int> pii;
const int N = 400009, inf = 0x3f3f3f3f;
int n, m;
struct edge {
    int to, w, next;
} e[N];

struct Prim {
    int head[N], idx;
    int dist[N];
    bool vis[N];

    void init() {
        idx = 0;
        for (int i = 1; i <= n; i++) head[i] = -1;
    }

    void add(int a, int b, int c) {
        e[idx].to = b;
        e[idx].w = c;
        e[idx].next = head[a];
        head[a] = idx++;
    }

    int prim(int x) {
        int cnt = 0, sum = 0;//cnt为加点数 sum为总边权和
        for (int i = 1; i <= n; i++) dist[i] = inf, vis[i] = false;
        dist[x] = 0;
        priority_queue<pii, vector<pii>, greater<pii>> q;
        q.push({dist[x], x});
        while (!q.empty() && cnt < n) {
            int t = q.top().second;
            int dis = q.top().first;
            q.pop();
            if (vis[t]) continue;
            cnt++;
            sum += dis;
            vis[t] = true;
            for (int i = head[t]; i != -1; i = e[i].next) {
                int tar = e[i].to;
                if (dist[tar] > e[i].w) {
                    dist[tar] = e[i].w;
                    q.push({dist[tar], tar});
                }
            }
        }
        if (cnt == n) return sum;
        return -1;//非联通
    }
} prim;
```

#### Kruskal

```cpp
typedef pair<int, int> pii;
const int N = 400009, inf = 0x3f3f3f3f;
int n, m;

struct Edge {
    int x, y, w;

    bool operator<(const Edge &k) const {
        return w < k.w;
    }
} edge[N];

int f[N];

int find(int x) {
    int r = x;
    while (x != f[x]) x = f[x];
    while (r != x) {
        int j = f[r];
        f[r] = x;
        r = j;
    }
    return x;
}

int Kruskal() {
    for (int i = 1; i <= n; i++) f[i] = i;
    int cnt = 0, sum = 0;
    sort(edge + 1, edge + 1 + m);
    for (int i = 1; i <= m; i++) {
        int x = find(edge[i].x), y = find(edge[i].y);
        if (x != y) {
            f[x] = y;
            cnt++;
            sum += edge[i].w;
        }
    }
    if (cnt == n - 1) return sum;
    return -1;
}
```



## Dijkstra

```cpp
typedef pair<int, int> pii;
const int N = 100009, inf = 0x3f3f3f3f;
int n, m;
struct edge {
    int to, w, next;
} e[N];

struct dijkstra {
    int head[N], idx;
    int dist[N];
    bool vis[N];

    void init() {
        idx = 0;
        for (int i = 1; i <= n; i++) head[i] = -1;
    }

    void add(int a, int b, int c) {
        e[idx].to = b;
        e[idx].w = c;
        e[idx].next = head[a];
        head[a] = idx++;
    }

    void dij(int x) {
        for (int i = 1; i <= n; i++) dist[i] = inf, vis[i] = false;
        dist[x] = 0;
        priority_queue<pii, vector<pii >, greater<pii>> q;
        q.push({dist[x], x});
        while (!q.empty()) {
            int t = q.top().second;
            int dis = q.top().first;
            q.pop();
            if (vis[t]) continue;
            vis[t] = true;
            for (int i = head[t]; i != -1; i = e[i].next) {
                int tar = e[i].to;
                if (dist[tar] > e[i].w + dis) {
                    dist[tar] = e[i].w + dis;
                    q.push({dist[tar], tar});
                }
            }
        }
    }
} dij;
```



## LCA

### 倍增求法

```cpp
const int inf = 0x3f3f3f3f, N = 100010, Log = 20;
int anc[N][Log + 5], depth[N];
vector<int> e[N];

void dfs(int k, int fa) {
    anc[k][0] = fa;
    depth[k] = depth[fa] + 1;
    for (int i = 0; i < e[k].size(); i++) {
        int to = e[k][i];
        if (to != fa) {
            dfs(to, k);
        }
    }
}

void init(int root, int n) {//初始化
    depth[0] = 0;
    dfs(root, 0);
    for (int j = 1; j <= Log; j++) {
        for (int i = 1; i <= n; i++) {
            anc[i][j] = anc[anc[i][j - 1]][j - 1];
        }
    }
}

int rush(int k, int h) {//从节点k往上找h个祖先
    for (int j = 1, i = 0; j <= h; j <<= 1, i++) {
        if (j & h) k = anc[k][i];
    }
    return k;
}

int query(int x, int y) {//询问x和y的最小公共祖先
    if (depth[x] < depth[y]) swap(x, y);
    x = rush(x, depth[x] - depth[y]);//调整为相同深度
    if (x == y) return x;
    for (int i = Log; i >= 0; i--) {
        if (anc[x][i] != anc[y][i]) {
            x = anc[x][i];
            y = anc[y][i];
        }
    }
    return anc[x][0];
}
```

### 欧拉序求法

```cpp
const int N = 100010, Log = 30;
int logx[N], st[N][Log];//logx[i]即log(i)向下取整  st[i][j]表示i为起点长度为2^j区间最值
int first[N], id[N], tot, deep[N];//id为欧拉序
vector<int> f[N];

void dfs(int k, int fa, int d) {
    id[++tot] = k; //id[]存储欧拉序所对应的树的节点编号
    deep[tot] = d; //deep[]存储每个dfs遍历序列号的深度
    first[k] = tot; //first[x]=y表示树的第x号节点在dfs遍历序列第一次出现的位置y
    for (int i = 0; i < f[k].size(); i++) {
        int u = f[k][i];
        if (u != fa) {
            dfs(u, k, d + 1);
            id[++tot] = k;
            deep[tot] = d;
        }
    }
}

int Min(int x, int y) {
    return deep[x] > deep[y] ? y : x;
}

void init(int n) {//更新st表和logx
    logx[0] = -1;
    for (int i = 1; i <= n; i++)logx[i] = logx[i >> 1] + 1;
    for (int i = 1; i <= n; i++)st[i][0] = i;
    for (int j = 1; (1 << j) <= n; j++) {
        for (int i = 1; i + (1 << j) - 1 <= n; i++) {
            st[i][j] = Min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);
        }
    }
}

int LCA(int u, int v) {//求u和v节点的lca
    int l = first[u], r = first[v];
    if (l > r)swap(l, r);
    int k = logx[r - l + 1];
    return id[Min(st[l][k], st[r - (1 << k) + 1][k])];
}
```





## Tarjan

### 求割点割边点双
```cpp
const int N = 1e3 + 10, M = 1e6 + 10;

struct Edge{
    int v, id;
};

vector<Edge> e[N];
vector<int> bcc[N];//点双
bool cut[N], cut_edge[M];// 割点 割边
int low[N], dfn[N], tot, bcc_cnt, sta[N], top;

void tarjan(int u, int fa) {
    low[u] = dfn[u] = ++tot;
    sta[++top] = u;
    int child = 0, x;
    for (Edge i : e[u]) {
        int v = i.v, id = i.id;
        if (!dfn[v]) {
            child++;
            tarjan(v, u);
            low[u] = min(low[v], low[u]);
            if ((!fa && child > 1) || (fa && low[v] >= dfn[u])) {//割点
                cut[u] = true;
            }
            if (low[v] > dfn[u]) {//割边
                cut_edge[id] = true;
            }
            if (low[v] >= dfn[u]) {//点双
                bcc_cnt++;
                do{
                    x = sta[top--];
                    bcc[bcc_cnt].push_back(x);
                }while(x != v);
                bcc[bcc_cnt].push_back(u);
            }
        } else if (v != fa) {
            low[u] = min(low[u], dfn[v]);
        }
    }
}

void solve() {
    int n, m;
    cin >> n >> m;
    for(int i = 0, u, v; i < m; i++){
        cin >> u >> v;
        e[u].push_back({v, i});
        e[v].push_back({u, i});
    }
    for(int i = 1; i <= n; i++){
        if(!dfn[i]){
            top = 0;
            tarjan(i, 0);
        }
    }
}
```

### 求强连通分量(scc)
2-sat问题 <br />
对于一对互斥关系(a, b) <br />
将a与!b连边, b与!a连边, 跑scc即可
```cpp
有n对点, 每对点只能选一个, m对关系, 每对关系给出u, v两点, 表示u和v不能同时选
输出方案或不成立(NIE)
编号为 2i-1 和 2i 的代表属于第 i 对点

#include <bits/stdc++.h>

using namespace std;

const int N = 1e5 + 10, M = 1e6 + 10;

vector<int> e[N];
int low[N], dfn[N], tot, sta[N], top;
int scc_cnt, scc[N], in[N];

void tarjan(int u) {
    low[u] = dfn[u] = ++tot;
    sta[++top] = u;
    int x;
    in[u] = 1;
    for (int v : e[u]) {
        if (!dfn[v]) {
            tarjan(v);
            low[u] = min(low[v], low[u]);
        } else if (in[v]) {
            low[u] = min(low[u], dfn[v]);
        }
    }
    if (dfn[u] == low[u]) {// scc强连通分量
        scc_cnt++;
        do {
            x = sta[top--];
            in[x] = 0;
            scc[x] = scc_cnt;  // 染色
        } while (x != u);
    }
}

int re(int x){
    return ((x & 1) ? (x + 1) : (x - 1));
}

void solve() {
    int n, m;
    cin >> n >> m;
    for(int i = 0, u, v; i < m; i++){
        cin >> u >> v;
        e[u].push_back(re(v));
        e[v].push_back(re(u));
    }
    for(int i = 1; i <= n * 2; i++){
        if(!dfn[i]){
            top = 0;
            tarjan(i);
        }
    }
    for(int i = 1; i <= n * 2; i += 2){
        if(scc[i] == scc[i + 1]){
            cout << "NIE\n";
            return;
        }
    }
    for(int i = 1; i <= n * 2; i += 2){
        int f1 = scc[i], f2 = scc[i + 1];
        if(f1 < f2){
            cout << i << '\n';
        }else{
            cout << i + 1 << '\n';
        }
    }
}

int main() {
    int T = 1;
    ios::sync_with_stdio(false);
    //cin >> T;
    while (T--) solve();
    return 0;
}
```





## 二分图

### 最大匹配(匈牙利)

k-正则图：各顶点的度均为 k 的无向简单图

最大匹配数：最大匹配的匹配边的数目

最大独立集数：选取最多的点集，使点集中任意两点均不相连

最小点覆盖数：选取最少的点集，使任意一条边都至少有一个端点在点集中

- 最大匹配数 = 最小点覆盖数
- 最大独立集数 = 顶点数 - 最大匹配数

```cpp
int n, m;
int mp[N][N], link[N];// 存图  link i 右部图i点在左部图的连接点
bool vis[N];// 是否在交替路中

bool dfs(int u){
    for(int v = 1; v <= m; v++){
        if(vis[v] || !mp[u][v]) continue;
        vis[v] = true;
        if(link[v] == -1 || dfs(link[v])){
            link[v] = u;
            return true;
        }
    }
    return false;
}

int hungarian(){
    int ans = 0;
    for(int i = 1; i <= m; i++) link[i] = -1;
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= m; j++) vis[j] = false;
        if(dfs(i)) ans++;
    }
    return ans;
}

void solve() {
    int e;
    cin >> n >> m >> e;
    for(int i = 0, u, v; i < e; i++){
        cin >> u >> v;
        mp[u][v] = true;
    }
    cout << hungarian();
}
```

也可建立一个源点和汇点, 将源点连向所有左部点, 左部点连向右部点, 右部点连向汇点, 且所有流量为1, 然后跑最大流即为最大匹配

### 最大权匹配

#### KM ( 时间复杂度 $n^3$ )

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef pair<int, int> pii;
//Data
const int N = 500 + 10;
const ll inf = 1e11;
int nx, ny;

//KM
ll c[N], e[N][N], kb[N], ka[N];
int mb[N], p[N], vb[N];

void Bfs(int u) {
    int a, v, vl = 0;
    ll d;
    for (int i = 1; i <= nx; i++) p[i] = 0, c[i] = inf;
    mb[v] = u;
    do {
        a = mb[v], d = inf, vb[v] = 1;
        for (int b = 1; b <= nx; b++)
            if (!vb[b]) {
                if (c[b] > ka[a] + kb[b] - e[a][b])
                    c[b] = ka[a] + kb[b] - e[a][b], p[b] = v;
                if (c[b] < d) d = c[b], vl = b;
            }
        for (int b = 0; b <= nx; b++)
            if (vb[b]) ka[mb[b]] -= d, kb[b] += d;
            else c[b] -= d;
        v = vl;
    } while (mb[v]);
    while (v) mb[v] = mb[p[v]], v = p[v];
}

ll KM() {
    for (int i = 1; i <= nx; i++) mb[i] = 0, ka[i] = kb[i] = 0;
    for (int a = 1; a <= nx; a++) {
        for (int b = 1; b <= nx; b++) vb[b] = 0;
        Bfs(a);
    }
    ll res = 0;
    for (int b = 1; b <= nx; b++) res += e[mb[b]][b];
    return res;
}

void solve() {
    int n, m;
    scanf("%d%d", &n, &m);
    nx = n, ny = n;
    for (int a = 1; a <= nx; a++)
        for (int b = 1; b <= nx; b++) e[a][b] = -inf;
    for (int i = 1, u, v, w; i <= m; i++) {
        scanf("%d%d%d", &u, &v, &w);
        e[u][v] = max(e[u][v], w * 1ll);
    }
    printf("%lld\n", KM());
    for (int u = 1; u <= ny; u++) printf("%d ", mb[u]);
    puts("");
}

int main() {
    solve();
    return 0;
}
```

#### 费用流( 时间复杂度 $n\times e \times f$ 或 $e \times log(n) \times f$ )





## 欧拉回路

```cpp
// 若有奇数度数的点 可先建若干条虚边使其度数变为偶数
const int N = 5e5 + 10;

struct Edge{
    int to, next;
    int index; // 边在图中编号
    int dir; // 方向
    bool flag;
}edge[N];
int head[N], tot;

void init(){
    memset(head, -1, sizeof(head));
    tot = 0;
}

void add(int u, int v, int index){
    edge[tot] = {v, head[u], index, 0, false};
    head[u] = tot++;
    edge[tot] = {u, head[v], index, 1, false};
    head[v] = tot++;
}

int du[N];// 点的度
vector<int> ans;

void dfs(int u){
    for(int i = head[u]; i != -1; i = edge[i].next){
        if(!edge[i].flag){
            edge[i].flag = true;
            edge[i ^ 1].flag = true;
            dfs(edge[i].to);
            ans.push_back(i);
        }
    }
}
```





## 最大流

```cpp
const int inf = 0x3f3f3f3f, N = 20000, M = 2e5 + 10;
struct edge {
    int to, next;
    ll w;//w为流量
} e[M];
int head[N], idx, cur[N];
int dist[N], s, t, n;
bool vis[N];

void init() {
    idx = 0;
    memset(head, -1, sizeof(head));
}

void _add(int a, int b, ll c) {
	e[idx] = {b, head[a], c};
    head[a] = idx++;
}

void add(int a, int b, ll c){
    _add(a, b, c);
    _add(b, a, 0);
}

bool bfs() {
    for (int i = 1; i <= n; i++) vis[i] = false;
    queue<int> q;
    q.push(s);
    vis[s] = true;
    dist[s] = 0;
    while (!q.empty()) {
        int x = q.front();
        q.pop();
        for (int i = head[x]; i != -1; i = e[i].next) {
            int to = e[i].to;
            ll w = e[i].w;
            if (!vis[to] && w) {
                vis[to] = true;
                dist[to] = dist[x] + 1;
                q.push(to);
            }
        }
    }
    return vis[t];
}

ll dfs(int x, ll flow) {
    if (x == t || !flow) return flow;
    ll delta = 0, f;
    for (int i = cur[x]; i != -1; i = e[i].next) {
        int to = e[i].to;
        ll w = e[i].w;
        cur[x] = i;
        if (dist[to] == dist[x] + 1 && (f = dfs(to, min(flow, w))) > 0) {
            e[i].w -= f;
            e[i ^ 1].w += f;
            flow -= f;
            delta += f;
            if (flow == 0) break;
        }
    }
    return delta;
}

ll MaxFlow() {
    ll ans = 0;
    while (bfs()) {
        for (int i = 1; i <= n; i++) cur[i] = head[i];
        ans += dfs(s, inf);
    }
    return ans;
}
```





## 最小费用最大流(费用流)

### SPFA( 时间复杂度 $n\times e \times f$ )

```cpp
const int inf = 0x3f3f3f3f, N = 100010;
struct edge {
    int to, next;
    ll w, fee;//w为流量  fee为费用
} e[N];
int head[N], idx;
int pre[N], id[N];//pre 前一个节点   id 当前节点的边的idx
int s, t, n;
ll dist[N], flow[N];//dist 费用(距离)  flow 流量
bool vis[N];

void init() {
    idx = 0;
    for (int i = 1; i <= n; i++) head[i] = -1;
}

void add(int a, int b, ll c, ll fee) {
    e[idx].to = b;
    e[idx].w = c;
    e[idx].next = head[a];
    e[idx].fee = fee;
    head[a] = idx++;
}

bool spfa() {
    for (int i = 1; i <= n; i++) {
        vis[i] = false;
        dist[i] = inf;
        flow[i] = inf;
    }
    queue<int> q;
    q.push(s);
    vis[s] = true;
    pre[t] = -1;
    dist[s] = 0;
    while (!q.empty()) {
        int x = q.front();
        q.pop();
        vis[x] = false;
        for (int i = head[x]; i != -1; i = e[i].next) {
            int to = e[i].to;
            ll w = e[i].w, fee = e[i].fee;
            if (w && dist[to] > dist[x] + fee) {
                dist[to] = dist[x] + fee;
                flow[to] = min(flow[x], w);
                pre[to] = x;
                id[to] = i;
                if (!vis[to]) {
                    q.push(to);
                    vis[to] = true;
                }
            }
        }
    }
    return dist[t] != inf;
}

void MinFee() {
    ll minfee = 0, maxflow = 0;
    while (spfa()) {
        int now = t;
        maxflow += flow[t];
        minfee += flow[t] * dist[t];
        while (now != s) {
            e[id[now]].w -= flow[t];
            e[id[now] ^ 1].w += flow[t];
            now = pre[now];
        }
    }
    printf("%lld %lld\n", maxflow, minfee);
}
```

### dij ( 边权为正,  时间复杂度 $e \times log(n) \times f$ )

```cpp
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, int> pll;
const int N = 1e6 + 10, M = 2e7;
const ll inf = 1e10;
struct edge {
    int to, next;
    ll w, fee;//w为流量  fee为费用
} e[N];
int head[N], idx;
int pre[N], id[N];//pre 前一个节点   id 当前节点的边的idx
int s, t, n;
ll dist[N], flow[N], h[N];//dist 费用(距离)  flow 流量
bool vis[N];

void init() {
    idx = 0;
    for (int i = 1; i <= n; i++) head[i] = -1;
}

void add(int a, int b, ll c, ll fee) {
    e[idx].to = b;
    e[idx].w = c;
    e[idx].next = head[a];
    e[idx].fee = fee;
    head[a] = idx++;
}

bool dij() {
    for (int i = 1; i <= n; i++) {
        vis[i] = false;
        dist[i] = inf;
        flow[i] = inf;
    }
    dist[s] = 0;
    pre[t] = -1;
    priority_queue<pll, vector<pll>, greater<pll>> q;
    q.push({dist[s], s});
    while(!q.empty()){
        int x = q.top().second;
        q.pop();
        if(vis[x]) continue;
        vis[x] = true;
        for (int i = head[x]; i != -1; i = e[i].next) {
            int to = e[i].to;
            ll w = e[i].w, fee = e[i].fee;
            if (w && dist[to] > dist[x] + h[x] - h[to] + fee) {
                dist[to] = dist[x] + h[x] - h[to] + fee;
                flow[to] = min(flow[x], w);
                pre[to] = x;
                id[to] = i;
                q.push({dist[to], to});
            }
        }
    }
    return dist[t] != inf;
}

ll MinFee() {
    ll minfee = 0, maxflow = 0;
    while (dij()) {
        for(int i = 1; i <= n; i++) {
            h[i] += dist[i];
        }
        int now = t;
        maxflow += flow[t];
        minfee += flow[t] * h[t];
        while (now != s) {
            e[id[now]].w -= flow[t];
            e[id[now] ^ 1].w += flow[t];
            now = pre[now];
        }
    }
    return minfee;
}
```

```cpp
from oiwiki

#include <algorithm>
#include <cstdio>
#include <cstring>
#include <queue>
#define INF 0x3f3f3f3f
using namespace std;

struct edge {
  int v, f, c, next;
} e[100005];

struct node {
  int v, e;
} p[10005];

struct mypair {
  int dis, id;

  bool operator<(const mypair& a) const { return dis > a.dis; }

  mypair(int d, int x) { dis = d, id = x; }
};

int head[5005], dis[5005], vis[5005], h[5005];
int n, m, s, t, cnt = 1, maxf, minc;

void addedge(int u, int v, int f, int c) {
  e[++cnt].v = v;
  e[cnt].f = f;
  e[cnt].c = c;
  e[cnt].next = head[u];
  head[u] = cnt;
}

bool dijkstra() {
  priority_queue<mypair> q;
  for (int i = 1; i <= n; i++) dis[i] = INF;
  memset(vis, 0, sizeof(vis));
  dis[s] = 0;
  q.push(mypair(0, s));
  while (!q.empty()) {
    int u = q.top().id;
    q.pop();
    if (vis[u]) continue;
    vis[u] = 1;
    for (int i = head[u]; i; i = e[i].next) {
      int v = e[i].v, nc = e[i].c + h[u] - h[v];
      if (e[i].f && dis[v] > dis[u] + nc) {
        dis[v] = dis[u] + nc;
        p[v].v = u;
        p[v].e = i;
        if (!vis[v]) q.push(mypair(dis[v], v));
      }
    }
  }
  return dis[t] != INF;
}

void spfa() {
  queue<int> q;
  memset(h, 63, sizeof(h));
  h[s] = 0, vis[s] = 1;
  q.push(s);
  while (!q.empty()) {
    int u = q.front();
    q.pop();
    vis[u] = 0;
    for (int i = head[u]; i; i = e[i].next) {
      int v = e[i].v;
      if (e[i].f && h[v] > h[u] + e[i].c) {
        h[v] = h[u] + e[i].c;
        if (!vis[v]) {
          vis[v] = 1;
          q.push(v);
        }
      }
    }
  }
}

int main() {
  scanf("%d%d%d%d", &n, &m, &s, &t);
  for (int i = 1; i <= m; i++) {
    int u, v, f, c;
    scanf("%d%d%d%d", &u, &v, &f, &c);
    addedge(u, v, f, c);
    addedge(v, u, 0, -c);
  }
  spfa();  // 先求出初始势能
  while (dijkstra()) {
    int minf = INF;
    for (int i = 1; i <= n; i++) h[i] += dis[i];
    for (int i = t; i != s; i = p[i].v) minf = min(minf, e[p[i].e].f);
    for (int i = t; i != s; i = p[i].v) {
      e[p[i].e].f -= minf;
      e[p[i].e ^ 1].f += minf;
    }
    maxf += minf;
    minc += minf * h[t];
  }
  printf("%d %d\n", maxf, minc);
  return 0;
}
```
