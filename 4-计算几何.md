# 计算几何

## 二维几何：点与向量

```cpp
#define y1 yy1
#define nxt(i) ((i + 1) % s.size())
typedef double LD;
const LD PI = 3.14159265358979323846;
const LD eps = 1E-10;
int sgn(LD x) { return fabs(x) < eps ? 0 : (x > 0 ? 1 : -1); }
struct L;
struct P;
typedef P V;
struct P {
    LD x, y;
    explicit P(LD x = 0, LD y = 0): x(x), y(y) {}
    explicit P(const L& l);
};
struct L {
    P s, t;
    L() {}
    L(P s, P t): s(s), t(t) {}
};

P operator + (const P& a, const P& b) { return P(a.x + b.x, a.y + b.y); }
P operator - (const P& a, const P& b) { return P(a.x - b.x, a.y - b.y); }
P operator * (const P& a, LD k) { return P(a.x * k, a.y * k); }
P operator / (const P& a, LD k) { return P(a.x / k, a.y / k); }
inline bool operator < (const P& a, const P& b) {
    return sgn(a.x - b.x) < 0 || (sgn(a.x - b.x) == 0 && sgn(a.y - b.y) < 0);
}
bool operator == (const P& a, const P& b) { return !sgn(a.x - b.x) && !sgn(a.y - b.y); }
P::P(const L& l) { *this = l.t - l.s; }
ostream &operator << (ostream &os, const P &p) {
    return (os << "(" << p.x << "," << p.y << ")");
}
istream &operator >> (istream &is, P &p) {
    return (is >> p.x >> p.y);
}

LD dist(const P& p) { return sqrt(p.x * p.x + p.y * p.y); }
LD dot(const V& a, const V& b) { return a.x * b.x + a.y * b.y; }
LD det(const V& a, const V& b) { return a.x * b.y - a.y * b.x; }
LD cross(const P& s, const P& t, const P& o = P()) { return det(s - o, t - o); }
// --------------------------------------------
```

## Andrew

```cpp
// 求凸包周长
#include<bits/stdc++.h>
using namespace std;

const double eps = 1e-9, pi = acos(-1.0);
const int N = 1e5 + 10;

int n, cnt, m;

int sgn(double x) {
    if(fabs(x) < eps)   return 0;
    if(x > 0)   return 1;
    return -1;
}

struct point {
    double x, y;
    point(double a = 0.0, double b = 0.0) : x(a), y(b) {}
    bool operator < (point t) {
        if(sgn(x - t.x) == 0)  return y < t.y;
        return x < t.x;
    }
    point operator - (point p){
        return {x - p.x, y - p.y};
    }
    double operator ^ (point p){
        return x * p.y - y * p.x;
    }
}p[N], ans[N];

double dis(point a, point b) {
    a = a - b;
    return sqrt(a.x * a.x + a.y * a.y);
}

void Andrew() {
    sort(p, p + n);
    int p1 = 0, p2;
    for(int i = 0; i < n; i++) {
        while(p1 > 1 && sgn((ans[p1] - ans[p1 - 1]) ^ (p[i] - ans[p1 - 1])) <= 0)   p1--;
        ans[++p1] = p[i];
    }
    p2 = p1;
    for(int i = n - 2; i >= 0; i--) {
        while(p2 > p1 && sgn((ans[p2] - ans[p2 - 1]) ^ (p[i] - ans[p2 - 1])) <= 0)  p2--;
        ans[++p2] = p[i];
    }
    double target = 0.0;
    for(int i = 1; i < p2; i++){
        target += dis(ans[i], ans[i + 1]);
    }
    printf("%.2f\n", target);
}

int main() {
    scanf("%d", &n);
    for(int i = 0; i < n; i++)
        scanf("%lf%lf", &p[i].x, &p[i].y);
    Andrew();
    return 0;
}
```

## CHT

```cpp
// 维护上凸壳
struct Line {
    ll k, b;
    double intersect(Line l) {
        //交点x坐标
        double db = l.b - b;
        double dk = k - l.k;
        return db / dk;
    }
 
    ll calc (int x) {
        return k * x + b;
    }
};
 
struct CHT {
    vector<double> x; // 相邻线交点
    vector<Line> line; // 线
 
    void init(Line l) {
        x.push_back(-inf);
        line.push_back(l);
    }
 
    void addLine(Line l) {
        while (line.size() >= 2 && l.intersect(line[line.size() - 2]) <= x.back()) {
            x.pop_back();
            line.pop_back();
        }
        x.push_back(l.intersect(line.back()));
        line.push_back(l);
    }
 
    ll query(int qx) {
        int id = upper_bound(x.begin(), x.end(), qx) - x.begin() - 1; // 计算点属于的线id
        return line[id].calc(qx);
    }
};
```

