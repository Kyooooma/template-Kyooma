# 字符串

## KMP

```cpp
const int N = 100010;
int ne[N];
string s, t;//s为原串 t为匹配串
void getNext() {//求next数组 ne[i]表示长度为i的最长公共前后缀长度(ne[i]<i)
    ne[0] = -1;
    int k = -1, j = 0;
    while (j < t.size()) {
        if (k == -1 || t[k] == t[j]) {
            j++;
            k++;
            ne[j] = k;
        } else k = ne[k];
    }
}

int kmp() {//返回匹配下标
    int i = 0, j = 0;
    int n = (int)s.size(), m = (int)t.size();
    while (i < n && j < m) {
        if (j == -1 || s[i] == t[j]) {
            i++;
            j++;
        } else {
            j = ne[j];
        }
    }
    if (j == m) return i - m;
    return -1;
}
```



## 序列自动机

```cpp
构建:
for(int i = n; i >= 1; i--){
    for(int j = 0; j < 26; j++) ne[i - 1][j] = ne[i][j];
    ne[i - 1][s[i - 1] - 'a'] = i;
}

求三(或多个)个串的公共子序列个数:
int dfs(int p1, int p2, int p3){
    if(f[p1][p2][p3]) return f[p1][p2][p3];
    for(int i = 0; i < 26; i++){
        if(ne[0][p1][i] && ne[1][p2][i] && ne[2][p3][i]){
            f[p1][p2][p3] = (f[p1][p2][p3] + dfs(ne[0][p1][i], ne[1][p2][i], ne[2][p3][i])) % mod;
        }
    }
    f[p1][p2][p3] = (f[p1][p2][p3] + 1) % mod;
    return f[p1][p2][p3];
}
```



## 字典树

```cpp
//对数排序 查找排序后第k个数 每个数 <= 1e9
const int N = 5000010;// 总长度
int trie[N][10], tot, sum[N][10], ssum = 0;
int color[N];

void insert(string s) {//插入
    int p = 0;
    ssum++;
    for (char i: s) {
        int c = i - '0';
        sum[p][c]++;
        if (!trie[p][c]) trie[p][c] = ++tot;
        p = trie[p][c];
    }
    color[p]++;
}

void insert(int x) {//x转换为字符
    string s;
    while (x) {
        char t = x % 10 + '0';
        s += t;
        x /= 10;
    }
    while (s.size() <= 10) s += '0';
    reverse(s.begin(), s.end());
    insert(s);
}

int find(int k) {//查找第k个数
    int res = 0, p = 0;
    while (k > 0) {
        for (int i = 0; i < 10; i++) {
            if (sum[p][i] < k) k -= sum[p][i];
            else {
                res = res * 10 + i;
                p = trie[p][i];
                k -= color[p];
                break;
            }
        }
    }
    return res;
}
```



## 字符串双哈希

```cpp
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;
const int N = 1e5 + 10;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
const pii mod = {1e9 + 7, 1e9 + 9};

const pii base = {131, 251};
pll pw[N];

pll operator*(const pll &p1, const pll &p2) {
    return {p1.first * p2.first % mod.first, p1.second * p2.second % mod.second};
}

pll operator+(const pll &p1, const pll &p2) {
    return {(p1.first + p2.first) % mod.first, (p1.second + p2.second) % mod.second};
}

pll operator-(const pll &p1, const pll &p2) {
    return {(p1.first - p2.first + mod.first) % mod.first, (p1.second - p2.second + mod.second) % mod.second};
}

struct Hash {
    vector<pll> f;
    int n{};

    void init(ll ss[], int _n) {
        n = _n;
        f.resize(n + 1, {0, 0});
        for (int i = 1; i <= n; i++) {
            ll ch = ss[i];
            f[i] = f[i - 1] * base + pll{ch, ch};
        }
    }

    pll ask(int l, int r) {//[l + 1, r]
        return f[r] - f[l] * pw[r - l];
    }
}
//记得初始化pw 
//pw[0] = {1, 1};
//for (int i = 1; i <= n; i++) pw[i] = pw[i - 1] * base;
```
