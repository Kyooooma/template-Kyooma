#  杂项

## 莫队

##### 时间复杂度 $O(\frac{n^2}{S} + mS)$, $n$为长度, $m$个询问, 块长为 $S$ (一般取 $\sqrt{n}$ 或 $\frac{n}{\sqrt{m}}$)

```cpp
int unit;
int a[N];
 
struct node {
    int l, r, id;
 
    bool operator < (const node &k) const {
        if (l / unit != k.l / unit) return l / unit < k.l / unit;
        return r < k.r;
    }
} q[N];
void add(int i) {
    
}
 
void sub(int i) {
    
}
void solve(){
    unit = (int)sqrt(m);// m个区间
    sort(q + 1, q + 1 + m);
    int L = 1, R = 0;
    for (int i = 1; i <= m; i++) {
        while (R < q[i].r) {
            R++;
            add(R);
        }
        while (R > q[i].r) {
            sub(R);
            R--;
        }
        while (L > q[i].l) {
            L--;
            add(L);
        }
        while (L < q[i].l) {
            sub(L);
            L++;
        }
    }   
}
```

## unordered_map 重写哈希函数
```cpp
struct HashFunc{
    static uint64_t splitmix64(uint64_t x) {
        // http://xorshift.di.unimi.it/splitmix64.c
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }
	template<typename T, typename U>
	size_t operator()(const std::pair<T, U>& p) const {
        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(p.first + FIXED_RANDOM) ^ splitmix64(p.second + FIXED_RANDOM);
	}
};

// 键值比较，哈希碰撞的比较定义，需要直到两个自定义对象是否相等
struct EqualKey {
	template<typename T, typename U>
	bool operator ()(const std::pair<T, U>& p1, const std::pair<T, U>& p2) const {
		return p1.first == p2.first && p1.second == p2.second;
	}
};
unordered_map<pii, int, HashFunc, EqualKey> mp;
```

## DSU

```cpp
struct DSU{
    int fa[N];
    void init(int n){
        for(int i=1;i<=n;i++) fa[i]=i;
    }
    int find(int x){
        return x == fa[x] ? x : fa[x] = find(fa[x]);
    }
    void merge(int x,int y){
        int fx=find(x), fy=find(y);
        if(fx != fy){
            fa[fx] = fy;
        }
    }
};
```

## Floyd判圈

```cpp
const ll mod = 1099511627776;

ll calc(ll x){
    return (x + (x >> 20) + 12345) % mod;
}

void Floyd_Cycle_Detection_Algorithm(){
    ll p1 = 1611516670, p2 = 1611516670; // 起始点
    do{
        p1 = calc(p1); // 移动一次
        p2 = calc(calc(p2)); // 移动两次
    }while(p1 != p2);
    // 存在环
    ll len = 0;// 环长
    do{
        p2 = calc(p2);
        len++;
    }while(p1 != p2);
    p1 = 1611516670;// 寻找环起点
    ll c1 = 0; // 起点到环起点的距离
    while(p1 != p2){
        p1 = calc(p1);
        p2 = calc(p2);
        c1++;
    }
    cout << p1 << ' ' << len << ' ' << c1 << '\n';
}
```

